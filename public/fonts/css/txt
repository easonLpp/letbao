1，分类：加高亮类：commin 下的 footer a 和 p  current:
2，左边固定，右边自适应 
   左右两边都有区域滚动

3，动态渲染：一进页面发送ajax先渲染左边，动态渲染左边一级分类，根据左边渲染右边
用 zepto

取得第一个一级分类 的id
不能写死，将来id可能不是从1 开始

保存一级的id 根据一级分类的id，渲染二级分类数据
封装一个方法  发送ajax请求

点击左边，给左侧所有a添加点击事件（事件委托），让被点击的a 高亮，排他（a 没有兄弟 siblings，应该找他父亲的兄弟的孩子 a），获取当前a 的id,重新渲染二级分类

对没有分类数据的进行判断（rows.length ===0）


搜索页面:
头部:返回上一页(js):history.back()/history.go(-1)
 javascript: (让当前连接不跳转,执行js);
 JavaScript:history.back();


搜索框
localStorage(只能存字符串类型)
 cookie sessionStorag

toString

渲染  删除单个 删除全部  添加 (用数组存, 因为数组有序,对象无序)

清空 渲染时进行判断,
添加确认框

删除单个:
给所有删除按钮 添加点击事件(事件委托),
获取数组,根据下标将数组对应项删除  自定义属性存储下标
将数组转成jsonstr,存储到本地,
重新渲染

arr.splice("从哪开始","删几个","替换1","替换2")
在任意位置:删除,替换,添加任意项


添加单个历史记录  往数组最前面添加
给搜索按钮,添加点击事件,
获取搜索关键字
获取数组,往数组最前面追加 unshift
转成jsonStr,存储到本地存储中
重新渲染

判断搜索关键字是否为空
重置搜索框

优化:
限制 搜索记录的条数 如果超过10条,保留前面的,删除最后一个

判断有没有重复项,如果有,先将重复项删除(判断是否有重复项)
  :index = arr.indexOf("查找某项");如果有index是下标,如果没有,index = -1


  点搜索后真正的功能,是跳转页面,显示与搜索所有有关的数据

  页面与页面的传值 :localStorage (少用)/ 地址栏传参:location.search
  decodeURL(location.search)//解析

  点搜索按钮后,跳转到搜索列表页,

  解析地址栏参数:

  obj[ key ]:key是一个变量
  obj.key :给obj加一个属性key


获取地址栏中的搜索关键字,
获取和渲染用的搜索框的值,不是地址栏的值

如果有高亮 需要排序,
parse
getSearch