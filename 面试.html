从输入URL到页面加载发生了什么:
1,DNS解析:
(把域名解析成一个 IP 地址)
(把 www.baidu.com（百度域名）解析成 220.181.112.244（百度的其中一个 IP 地址）)
每一台计算机的唯一标识是它的IP地址

当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换


IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；

域名（ DN ）：IP 地址由四个数字组成，中间用点号连接，难记忆，所以用于域名代替

DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。

浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；

搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；

搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；

操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80%
左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；

LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com
域的顶级域名服务器的地址；

LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；

LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址；

LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；

操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；

至此，浏览器已经得到了域名对应的 IP 地址。

域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，segmentfault.com 是 SF 的域名，根据这个域名可以找到
SF 的服务器，segmentfault.com/a/1190000003829539 是 URL ，可以根据这个 URL 定位到一篇博客；


2 TCP连接:
TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是
100%可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

主机向服务器发送一个建立连接的请求（您好，我想认识您）；

服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；

主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。

3 发送HTTP请求

当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。

浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；

服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；

服务器将得到的 HTML 文件发送给浏览器；

在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；

在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；

4 服务器处理请求并返回HTTP报文

5 浏览器解析渲染页面

6 连接结束;


主机向服务器发送一个断开连接的请求（不早了，我该走了）；

服务器接到请求后发送确认收到请求的信号（知道了）；

服务器向主机发送断开通知（我也该走了）；

主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；

为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。

第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2
个报文传输周期。


如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。




1.为什么需要三次握手，两次不可以吗？或者四次、五次可以吗？
我们来分析一种特殊情况，假设客户端请求建立连接，发给服务器SYN包等待服务器确认，服务器收到确认后，如果是两次握手，假设服务器给客户端在第二次握手时发送数据，数据从服务器发出，服务器认为连接已经建立，但在发送数据的过程中数据丢失，客户端认为连接没有建立，会进行重传。假设每次发送的数据一直在丢失，客户端一直SYN，服务器就会产生多个无效连接，占用资源，这个时候服务器可能会挂掉。这个现象就是我们听过的“SYN的洪水攻击”。
总结：第三次握手是为了防止：如果客户端迟迟没有收到服务器返回确认报文，这时会放弃连接，重新启动一条连接请求，但问题是：服务器不知道客户端没有收到，所以他会收到两个连接，浪费连接开销。如果每次都是这样，就会浪费多个连接开销。


TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100%
可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。


<!-- （2）为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

由于TCP连接时全双工的,因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭 -->